# OOP-Assignment2-NoorMinallah-24i-5579
Question 1 part a:
This function performs a recursive string transformation by swapping characters between two positions and then moving inward. It takes a character array and two indices b1 and b2 as parameters. The function first performs safety checks for null pointers and invalid indices, then calculates the string length. The core logic swaps the characters at positions b1-1 and b2-1 (converting from 1-based to 0-based indexing), then recursively calls itself with b1+1 and b2-1, creating a progressive character exchange that moves inward through the string. In the main function example with "COMPUTER" and parameters (3,7), it initiates a swapping process: first swapping positions 2 and 6 ('M' and 'E'), then positions 3 and 5 ('P' and 'U'), and so on, effectively reversing segments of the string through successive recursive calls until the indices meet or cross.

Question 1 part b:
This recursive function generates a numeric pattern based on an input number n. It uses a line parameter to track the current output line and produces different patterns depending on the line number. For line 1, it simply prints n; for line 2, it prints n/2 twice; and for subsequent lines, it prints multiple '1's followed by a calculated value n - line + 1. The number of '1's printed increases with each line (line-1 times). The function calls itself recursively with line+1 until the line number exceeds n. For example, if n=5, the output would be: line 1 shows "5", line 2 shows "2 2", line 3 shows "1 1 3", line 4 shows "1 1 1 2", and line 5 shows "1 1 1 1 1", demonstrating a pattern where early lines show larger numbers that gradually break down into more '1's with one larger value that decreases.

Question 2:
This C++ program implements a geographic feature analysis system using a singly linked list to manage different types of terrain features. The code defines a hierarchy of geographic features starting with an abstract base class Feature that serves as a template for specific feature types. Two concrete classes inherit from Feature: LandFeature for terrestrial elements like grasslands and deserts, and WaterFeature for aquatic elements like rivers and lakes. Each feature has a name and implements a virtual analyze() method that outputs a descriptive message about the detected feature type.

The program uses a Node class to create linked list elements that store feature objects along with unique identifiers, and a SinglyLinkedList class that manages the collection of nodes. The linked list supports operations including insertion at the end, deletion by feature ID, display of all features, and list reversal. The main function demonstrates the system's functionality by creating a list with various land and water features, displaying them, deleting a specific feature by ID, and then reversing the remaining list to show how the data structure can be manipulated. The implementation includes proper memory management through destructors that clean up both the node structures and the feature objects they contain.

Question 3:
This C++ program implements a library management system using a doubly linked list data structure to efficiently store and manipulate book records. The core of the system consists of two classes: a Node class that represents individual books with properties for ID, title, and author, along with both previous and next pointers to enable bidirectional traversal, and a Library class that manages the entire collection using head and tail pointers. The library provides comprehensive functionality including adding books to the beginning, end, or specific positions in the list; deleting books by their ID while properly maintaining the links between remaining nodes; and displaying the collection in both forward and backward directions to demonstrate the bidirectional traversal capabilities of the doubly linked list. The main function demonstrates these features by adding three books at different positions, displaying them in both directions, deleting one book, and showing the updated collection, illustrating how the data structure maintains integrity through all operations.

Question 4:
This C++ program implements a priority queue system for managing movie ticket customers, where service priority is given to customers purchasing more tickets. The system is built around a Customer class that stores each customer's ID, name, and number of tickets, along with a pointer to the next customer, and a PriorityTicketQueue class that manages the queue as a singly linked list sorted in descending order by ticket quantity. The key functionality includes an enqueue method that inserts new customers into the correct sorted position based on their ticket count (with higher ticket counts moving toward the front), a dequeue method that always serves the customer at the front who has the highest ticket purchase, and a display method that shows the current queue status. The main function demonstrates the priority system in action: initially adding three customers where "Mashalle" with 3 tickets gets priority over "Noor" with 2 tickets and "Inayah" with 1 ticket; then serving the highest-priority customer first; and finally showing how a returning customer ("Mashalle") with a new, higher ticket purchase of 4 jumps to the front of the remaining queue, illustrating the dynamic prioritization based on ticket quantity.

Question 5 part a:
Both ChangeLocationArray and ChangeLocationList reverse a substring using stacks. They take a character array and indices b1 and b2, then reverse the characters between those positions. The array-based version uses a dynamic array that automatically resizes when full. It pushes characters from position b1-1 to b2-1 onto the stack, then pops them back into the same range in reverse order. The list-based version does the same reversal but uses a linked list stack where each new character creates a node. Both methods transform "COMPUTER" to "COETUPMR" when reversing positions 3-7, but use different memory structures.Both pattern functions break down numbers into 2's and 1's using stacks. For each line from n down to 1, they decompose the number by repeatedly pushing '2' while possible, then pushing '1' for any remainder.
The stack reverses the decomposition order when popping, so for n=4:
Line 1: 4 becomes "2 2"
Line 2: 3 becomes "1 2"
Line 3: 2 becomes "2"
Line 4: 1 becomes "1"
